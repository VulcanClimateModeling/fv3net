#!/bin/bash
#
# Implementation Notes:
#
# This program is implemented using an entity-based paradigm. This is suitable
# for distributed workflows that modify remote resources.
#
# The functions in an entity-based API only allow for operations create, read,
# update, and delete (CRUD). These operations are applied to the entities to
# define the behavior of the system. Using only CRUD operations moves the state
# of the run execution into these entities, and makes the logic less reliant on
# local state, and therefore easier to translate to a distributed context.
#
# For a segmented run "Runs" and "Segments" are the main entities. Runs have
# many segments and some global data stores.


function usage {
    echo "This script can create segmented runs and appending segments to them."
    echo "It also provides low level commands used for debugging."
    echo "A segmented run can be local or on Google Cloud Storage."
    echo "Google Cloud Storage locations should start with 'gs:'."
    echo ""
    echo "Usage:"
    echo " runfv3 create <outputUrl> <fv3configFile>" > /dev/stderr
    echo " runfv3 append <outputUrl>" > /dev/stderr
    echo " runfv3 run-native <fv3config> <rundir>" > /dev/stderr
    echo ""
    echo "Segmented Run Commands:"
    echo "  create      Initialize a segmented run in GCS"
    echo "  append      Append a segment to a segmented run"
    echo ""
    echo "Low-level Commands:"
    echo "  run-native  Setup a run-directory and run the model. Used for "
    echo "              testing/debugging."
    echo ""
}


function createRun {
    url="$1"
    fv3config="$2"

    # TODO fix this command
    segmented-run-create $url $fv3config
}

function readRunConfig {
    # gsutil can't cat local files
    if [ ${runURL:0:3} == "gs:" ]; then
        gsutil cat "$runURL/fv3config.yml"
    else
        cat "$runURL/fv3config.yml"
    fi
}

function readRunLastSegment {
    url="$1"
    # gsutil can't ls local files
    if [ ${runURL:0:3} == "gs:" ]; then
        segments=($(gsutil ls "$runURL/artifacts" 2> /dev/null || echo "" ))
    else
        # need -p to get trailing slash, similar to gsutil ls
        segments=($(ls -p "$runURL/artifacts" 2> /dev/null || echo "" ))
    fi
    len="${#segments[@]}"
    if [[ $len -gt 0 ]]
    then
        if [ ${runURL:0:3} == "gs:" ]; then
            printf "%s" "${segments[-1]}"
        else
            printf "%s" "$runURL/artifacts/${segments[-1]}"
        fi
    fi
}

function appendSegment {
    set -e
    if [[ $# -ne 1 ]]
    then
        usage
        exit 1
    fi
    runURL="$1"

    workingDir="$(mktemp -d)"
    echo "Iteration run=$runURL working_directory=$workingDir" > /dev/stderr
    readRunConfig "$runURL" > "$workingDir/fv3config.yml"
    lastSegment=$(readRunLastSegment "$runURL")

    if [[ -n "$lastSegment" ]]
    then
        echo "Continuing from segment $lastSegment"
        # lastSegment includes trailing slash
        enable_restart "$workingDir/fv3config.yml" "${lastSegment}RESTART"
    else
        echo "First segment in $runURL"
    fi

    rundir="$workingDir/rundir"
    postProcessedOut="$workingDir/post_processed"

    set +e
    # TODO fix runSegment
    runSegment "$workingDir/fv3config.yml" "$rundir"
    fv3ExitCode=$?
    set -e

    echo "Skipping upload of following files:"
    cat "$rundir/preexisting_files.txt"
    post_process_run --chunks "$rundir/chunks.yaml" \
        --skip "$rundir/preexisting_files.txt" \
        "$rundir" "$postProcessedOut"
    append_run --no-copy "$postProcessedOut" "$runURL"

    echo "Cleaning up working directory"
    set +e
    rm -r "$workingDir"

    if [[ "$fv3ExitCode" -ne 0 ]]
    then
        exit 1
    fi
}


function verifyUrlEmpty {
    url="$1"
    set +e
    gsutil ls "$url" > /dev/null 2> /dev/null
    ret=$?
    set -e
    if [[ "$ret" -eq 0 ]]; then
        echo "The given output url (below) contains an object. Delete everything under output url and resubmit."
        echo "$url"
        exit 1
    fi
}


set -e
set -o pipefail


command="$1"

if [[ -n "$GOOGLE_APPLICATION_CREDENTIALS" ]]
then
    gcloud auth activate-service-account --key-file "$GOOGLE_APPLICATION_CREDENTIALS" 2> /dev/null
fi

case "$command" in 
    "create")
        shift
        createRun $@
        ;;
    "append")
        shift
        appendSegment "$1"
        ;;
    "run-native")
        shift
        runSegment $@
        ;;
    *)
        usage
        exit 1
        ;;
esac

